# Caesar-Cypher_Program
 You can encode or decode a message, providing a rotation based on a Caesar cypher. Rotation refers to the number of places up or down the alphabet each letter is moved. Ie, for one message, there are 25 different ways it could be encrypted. Additionally, it will automatically decrypt an encoded message with an unknown rotation, by processing the unknow message and decoding it with the rotation that provides the most matches with a library of english words. Give it a go yourself! The code is explained below in detail.
 
 Introduction: 
This program was developed in several stages. Initially I designed it to establish three variables: mode (encrypt/decrypt), message, and rotation. Throughout the process I ensured it was robust to deal with invalid inputs. After establishing these I designed a rotated message process, and a message analysis process. Upon getting to part four(auto-decrypt), I had to redesign the rotated message and message analysis process, to iterate through all possible rotations and identify the correct one to decrypt a message. To do this I made three functions, with the jobs of rotating a message, turning a message into raw words(getting rid of punctuation etc), and counting the frequencies of words.
Analysis:
Lines 8-20: I establish mode(encrypt/decrypt), allowing for a range of inputs such as (e/d) to make process faster, and use while true loop to ensure I get valid input
Lines 23-49: I use while true loop to establish message(if source is manual), or file path/name(if source is import), or repeat if inputs are invalid.
Lines 51-70: I use while true loop to establish rotation. Allows for a specified number within range, (“random”), or (“automatic”). Any invalid inputs will repeat this stage. If random, a random number within the range will be generated (used import random). If automatic, this later causes the program to determine the rotation which correctly de-crypts the message. 
Lines 72-95: rotated_message_function is the function I created to rotate a message. The arguments are the message to rotate, and the rotation value. It contains two functions within which serve to avoid repeating similar bits of code to process the possible elements in the text (uppercase,lowercase,punctuation,digits,white space). The function runs through each element, rotating letters (looping back to the other side of the alphabet if the rotation exceeds the range 0-25(26 not included as it’s the same as 0)), and leaves non-letter elements unchanged. The rotated letters are lowercase for message analysis purposes. I used import string to identify each element.
Lines 97-104: raw_message_function  is similar, the only argument is input message. It defines the string (raw_message) by concatenating only letter and white-space elements of the argument. Basically separating out non-letter elements. I made this for message analysis purposes.
Lines 106-114:  word_frequency_count_function takes an input message, makes a list of words within using .split() function, and creates a dictionary where the keys are the unique words, and values are the number of times they occur. 
Lines 116-127: if the rotation has been defined as an integer in range 1-25 by lines 51-70, this block defines rotated_message using the established message, and rotation. If the mode is defined as decrypt, the rotation is multiplied by -1, as the rotation goes the opposite way (Z->A). It then prints the rotated message in uppercase. After this, if mode is decrypt, lines 121-123 define raw_message using the decrypted(rotated) message, and defines word_frequency_count using the raw message. This is because in the message analysis, we want to analyse the un-encrypted message. Alternatively if mode is encrypt, lines 124-127 re-define rotated_message_function with a rotation of 0 (as we want the un-encrypted message for analysis) and use the rotated message this concatenates, to define raw_message, and use this to define word_frequency_count. I could have used the original message to define these functions without re-defining rotated_message_function with rotation argument 0, but this function also makes the output lowercase which I’d have to repeat elsewhere.
Lines 129-153: this “if” block determines the correct rotation to de-crypt a message in auto-decrypt mode, then defines the functions using this rotation for message analysis. First I created a list containing 25 zeros. Then using a for x in range(1,25) loop, I iterated through all the possible different rotations of the message to decrypt , using the functions to create a raw message (only words) from each iteration, then a dictionary of word frequencies for each iteration, then two lists with the keys (words) and values (frequencies) of the dictionary. Comparing the keys to a list of the words contained in words.txt, the frequencies of any matched words are summed and totaled in the list matching_words_count. The list index of each total, is equal to the current iteration of the “for” loop, which is the current rotation value. This method came after much re-design on my part. Originally I had not considered that I could re-define the three variables for each iteration very simply, ie in lines 74-75, I redefine rotated_message to (“”) every time I use the function. So originally I had created a list of 25 strings in place of rotated_message and raw_message, and a list of 25 dictionaries in place of word_frequency_count. This made things very complicated. Finally lines 145-151 sort the list, identifying the rotation with the most word matches, printing this rotation, and then re-defines the functions using this rotation for word analysis.
Lines 154-166: prints the total number of words using number of items in raw_words.split(), and prints the total unique words using number of items in word_frequency_count. It then prints the top ten words by sorting word_frequency_count (using key=lambda x:x[1], and reverse=True) this gives a list of keys(words) in descending order of their values(frequencies). A for loop is used to print these keys, up to the tenth. 
Lines 168-192: I create a dictionary to  count word lengths, to print longest and shortest words. Then a dictionary to count the frequencies of letters, to print the most common letter. Finally the code asks the user to input a filename, where it saves some of the stats collected.
Conclusion: My program accomplishes all tasks required in the brief, with the added extras of auto-decrypting the message for the user, using the highest number word matches with words.txt, and also saving message analysis to a filename of your choice.

